\input{pre}
\geometry{a4paper}
\title{盲目搜索实验报告}
\author{武自厚 20336014 保密管理}
\date{\today}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\true}[0]{\textbf{\emph{true}}}
\newcommand{\false}[0]{\textbf{\emph{false}}}
\newcommand{\img}[3]{\begin{figure}[H]
    \centering
    \includegraphics[width=#1\textwidth]{#2}
    \caption{#3}
\end{figure}}

\begin{document}
    \maketitle
    本次实验选择BFS算法以及IDS算法进行分析并实现.

    \section{原理分析}

    \subsection{搜索}
    几乎所有的搜索问题都可以形式化并抽象化为以下描述:

    \emph{根据已知的初始状态、行动、前进成本以及目标状态,通过各种算法获得从初始状态到
    某一个满足目标状态的状态序列.}

    其中,具体的方式取决于算法采用的策略,在这里BFS算法和IDS算法就具有一定区别.但是都一定具有搜索的\textbf{边界}以
    便于寻找新的更靠近目标的状态,即边界的扩展.

    \subsection{宽度优先搜索(BFS)}
    每一次即将扩展的状态放在边界的最后,也就是说使用队列数据结构来维护这个算法.只有当深度更小的所有状态都
    扩展后才会扩展一个状态.
    \subsection{迭代加深搜索(IDS)}
    迭代加深搜索的基础是深度优先搜索(DFS),即将扩展得到的状态置于边界的最前端,也就是用栈维护这个策略.而如果限制扩展的深度,超过规定深度
    的状态不予加入边界,这样的算法称为深度限制搜索(DLS).
    
    在上述两个算法的基础上,迭代加深搜索可以描述为:迭代执行深度为
    \(1,2,3,\dots\)的深度限制搜索,直至查找出结果或者达到设定的最大深度,返回\emph{false}.

    \section{效果分析}
    
    \subsection{完备性分析}

    算法执行的结果记录于\code{result.txt}中,可以发现两个算法给出了同样的结果,经过验证,这个结果是正确的.
    而深度优先搜索和迭代加深搜索算法都具有完备性(因为该问题是有限的而且行动代价一致),
    所以对于任何有解搜索问题都可以找到答案.

    \subsection{时间复杂度分析}
    
    理论上, 设\(b\)为分支因子(一个状态最多能扩展状态的数量), \(d\)为最短解的动作数量.则深度优先搜索的
    时间复杂度为\(O(b^{d})\),迭代加深搜索的时间复杂度为\(O(b^d)\).

    而代码实际运行状态记录于\code{result.txt}, BFS算法花费约0.004秒, IDS算法花费约0.1秒, 
    速度相差约25倍, 但是就问题的规模而言, 可以认为这两个算法处于同一时间复杂度.

    \subsection{空间复杂度分析}

    设\(b\)与\(d\)的含义与上文相同, 则在理论上, 深度优先搜索的空间复杂度为\(O(b^d)\), 
    而迭代加深搜索的空间复杂度为\(O(bd)\).

    \code{bfs.txt}和\code{ids.txt}分别记录了两种算法在扩展时边界的元素个数.
    可以看到BFS算法在这个问题中最大容量是9,而IDS算法最大需要的容量是7,
    对于这个规模的问题而言,可以说IDS算法显然优于BFS算法.

    \subsection{最优性分析}

    理论上,对于行动成本一致的问题而言(迷宫问题就具有这个性质),BFS以及IDS算法都具有最优性.因为在BFS
    算法中,节点会按照深度升序扩展,最先找到的路径必然是所有可能路径中深度最小的,再加上行动成本一致的条件,
    所以最先找到的路径即是最优路径.而对于IDS算法,由于每一次迭代会逐渐加深DFS的深度,最先找到的路径
    也必然是所有路径中深度最小的,也就是最优的.

    \section{思考题:算法优缺点分析}

    \subsection{宽度优先搜索(BFS)}
    
    BFS算法的优点在于易于实现,在行动成本一致的时候具有最优性;缺点是时间、空间复杂度都比较平庸.
    
    介于它在行动成本一致时具有最优性,它可以适用于类似游戏中NPC自动寻路的``方格寻路''问题.

    \subsection{深度优先搜索(DFS)}
    
    DFS算法的优点在于空间复杂度相较于其他算法来说非常小;但缺点是容易``不撞南墙不回头'',
    即不能保证完备性和最优性.
    
    这个算法适用于类似于``走迷宫''的\(b\)较小的问题.

    \subsection{深度受限搜索(DLS)}

    DLS算法具有DFS算法的优点,且时间复杂度稍有降低;但缺点依然是不能保证完备性和最优性.
    
    这个算法依然适用于类似``走迷宫''的问题,尤其是知道目标状态行动数量的时候.

    \subsection{迭代加深搜索(IDS)}

    IDS算法具有DFS算法的优点,且在迭代过程中可以保证完备性,在行动成本一致的时候具有最优性;
    缺点是无法应用于行动成本不一致的问题,即使采用``成本边界''代替,也会造成极大重复浪费.
    
    这个算法适用的场景类似于BFS算法的适用场景,且行动成本需要一致.

    \subsection{统一代价搜索(UCS)}

    UCS算法的时间与空间复杂度都较为优秀,且在行动成本不一致的问题中依然具有完备性和最优性;
    缺点是在行动成本不一致的问题中会退化为BFS算法,且由于优先队列弹出的时间复杂度大于队列的弹出,
    此时时间复杂度甚至会大于BFS算法.
    
    此算法适用于任何行动成本不一致的场景.

    \subsection{双向搜索}

    双向搜索算法的时间、空间复杂度都优于其他算法,且在双向BFS中可以满足完备性和最优性;
    缺点在于某些问题中可能很难实现向前搜索.
    
    这个算法适用于类似于无向图寻路的便于向前搜索的问题.



\end{document}